[TOC]



# ⭐排序

排序在我们的日常生活当中非常常见，在每个人的电脑中，我们可以按日期，文件大小或名称等给文件按照需求排序；在购物时，我们对于心仪商品的筛选可以按照销量，口碑，评价数量等进行排序；对于外卖或快递等，我们可以按照离自己远近的商家数量，商家口碑或评价高低进行排序。总之，排序随时存在于我们的身边，而各种各样的排序算法数不胜数，有插入排序和选择排序，有交换排序和归并排序，还有外部排序及内部排序等等。本章将介绍排序中的几种经典算法，以基本数据结构和C语言模拟实现。

## ✨排序算法分类

排序算法的种类很多，而整体根据数据的挪动规则可将排序分为几个大类：

1. 插入排序——包含直接插入排序，希尔排序
2. 选择排序——包含选择排序，堆排序
3. 交换排序——包含冒泡排序，快速排序
4. 归并排序



本章将按照从上到下的顺序依次介绍。

### 🌠插入排序

插入排序类似于纸牌游戏中取牌插入归类的过程，比如抽牌阶段由发牌员递牌到自己手中组成了一串随机的不连续牌组，此时我们会从左边开始一张一张向右将牌依次捋顺，保证捋牌的左侧第一张到当前牌都是有序的情况下，再继续向右取出并插入到左边有序的牌组中。这个过程就是插入排序，而插入排序最简单的算法为直接插入排序。

#### 🍧直接插入排序

直接插入排序就是上例卡牌类游戏排序的典型代表，作为模型而提取出来。对于一个数组而言，插入排序的过程就是从数组的最左边开始，一步步将每个数据从左向右依次排为有序，此后每新增一个随机数据，就可以直接穿插入左边的已有序数组中，实现“插入”的效果。对比之前学过的冒泡排序，即将最值数据交换冒到数组最右边的过程，直接插入排序没有出现数之间交换的过程，因为其每个数据的挪动都是直接向右覆盖，新值直接插入覆盖到原数据合适的位置上，故谓之“直接插入排序”。

🎀直接插入排序算法

```c
void InsertSort(int* arr, int sz)
{
	int* cur = arr, * prev = arr;			//定义新插入值的指针和前一个数指针
	while (++cur < &arr[sz])				//cur在数组范围内的整趟循环
	{
		int value = *cur;					//临时存储新插入的值
		while (prev >= arr)					//单趟循环，向前越界时停止
		{
			if (value < *prev)				//如果新插入的值比前一个小（规则可变）
			{
				*(prev-- + 1) = *prev;		//prev解引用后挪覆盖，再自减
			}
			else
			{
				break;						//发现新插入的值比prev大时停止单趟循环
			}
		}
		*(prev + 1) = value;				//将新值插入到prev的后一个数据上，并重置回到cur位置
		prev = cur;
	}
}
```

1. 对于一个数组先定义了两个均指向数组首元素地址的指针cur和prev，分别用于控制数组的整趟循环插入遍历和单趟向前插入循环。cur指针向首元素遍历至尾，每遍历得到一个新的元素，如果满足要求就向前对比并插入合适位置，prev指针在cur拿到值后用该值对cur左侧的所有值进行对比。
2. 以升序一个数组为例，cur每向后拿到一个值，将该值暂时存储起来放到整型变量value中，此后prev指向的值开始与value进行逐个比对，如果发现value值比prev指向的值更小，则说明该更小值value应该存在于更靠前的位置。为了要保持所有数据的相对顺序，则prev每向前挪动一位之前，就需先将其所指向的值往后挪动覆盖一位，目的是为了给value这个更小值腾出一个有效的数据空间，这个过程类似于顺序表的头插。
3. 使用临时变量value来存储cur指向位置的值是为了防止prev在向后挪动数据的过程中对cur指向数据的覆盖，从而导致如果对cur解引用，拿到的就是被覆盖的值，换句话说，通过指针cur访问到的值是会被随时改变的，而如果将访问到的值使用变量value暂时保存起来，即使指针指向的值被改变，也可以通过value拿到所需值与prev进行对比以及位置找到后的插入。

直接插入排序原理图

![直接插入排序](C:\Users\Shiki\Desktop\资料\博客\链表OJ题\图片素材\直接插入排序.gif)

4. 因为对比过程中数据不断后挪覆盖的原因，value最后的值插入也必须插入到prev+1的位置上，该位置上的值已经通过后挪覆盖备份起来了，而prev此时如果没有越界，其指向的值比value小，则说明value应该插入到prev指向的值之后，也即prev + 1的位置上。
5. 这里还需注意的两个细节是cur指针指向的数据总是比prev多一个位置，如果两个指针指向同一个位置的同一数据是没有科比性的，所以最开始就让cur前置自增，与prev拉开距离后，一前一后比对才有意义。同时需要注意，因为cur是前置自增，所以每次值成功插入后，prev需要复位到cur的位置上，再让cur自增，继续向后遍历的过程中保持prev与cur的一步距离差。
6. 整个过程可以发现cur向后遍历一遍，而prev几乎每次插入新值都要向前再次遍历到头。如果是有序或接近有序的最好情况，则prev几乎无需向前遍历对比和挪动数据，只需遍历指针cur一直向后遍历至数组末即可，此时时间复杂度接近O(N)；而如果是逆序的最坏情况，则cur每后移一次取到的值，都必须用prev将该value值送到数组首位置，此时时间复杂度为O(N^2^)。所以直接插入排序平均情况与冒泡算法一致，平均时间复杂度均为O(N^2^)。
7. 对比冒泡排序的交换算法，该直接插入排序的稳定性是其优点之一，因为每个数之间的排序并不会改变相同数之间的相对顺序，而冒泡排序算法则相对不稳定。

🌈测试用例——升序和降序

```c
int arr[] = { 3,1,8,9,0,4,7,2,5,10,6 };		//排升序
int arr1[] = { -3,9,-5,6,4,2,10,8,1};		//排降序
int sz = sizeof(arr) / sizeof(arr[0]);
InsertSort(arr, sz);
for (int i = 0; i < sz; i++)
{
    printf("%d ", arr[i]);
}
```

🌈观察结果

```c
//升序结果
0 1 2 3 4 5 6 7 8 9 10
//降序结果
10 9 8 6 4 2 1 -3 -5
```

🎃本章中大部分函数将不使用函数指针控制排序升降序规则，所以如果要使该算法支持降序打印，需要手动将value和*prev之间的对比规则由value < *prev改成value > *prev来手动实现。



---

#### 🍧希尔排序

直接插入排序对有序或接近有序的数据操作时效率很高，可以达到线性排序的效率，即几乎只需遍历一次数据就可以了，而上述分析也提到了对于没有顺序或完全逆序的数据而言，直接插入的效率就非常低了，因为插入排序每次只能将一个数据向前移动到指定位置，而不能与具有二分分治算法思路的快速排序，归并排序等进行比较。

1959年Donald Shell提出了希尔排序，该算法在直接插入排序的基础上划分为了多个分组，并对每个分组分别进行直接插入排序，这个阶段称为全部数据的预排序。预排序完成后的数组中数据已经接近有序甚至有序，此时再调用直接插入排序就可以以极高的效率将数据全部排成顺序了。

🎀希尔排序算法

```c
void ShellSort(int* arr, int sz)
{
	int gap = sz;								//定义gap间隔
	while (gap > 1)								//当gap不为0时，执行预排序或直接插入排序
	{
		int* cur = arr, * prev = arr;			//分组执行直接插入排序
		gap = gap / 3 + 1;						//每次将gap间隔缩小为上一次的1/3
		while (cur < &arr[sz - gap])			//控制每个分组依次进行单趟排序的结束条件
		{
			int value = *(cur + gap);			//直接插入排序，cur与prev的增减间隔变为gap
			while (prev >= arr)
			{
				if (value < *prev)				//升序<，降序>
				{
					*(prev + gap) = *prev;
					prev -= gap;
				}
				else
				{
					break;
				}
			}
			*(prev + gap) = value;				//将新数据插入到合适的位置，因为间距为gap，所以为prev + gap上
			cur++;								//每组交替进行单趟插入排序
			prev = cur;
		}
	}
}
```

1. 希尔排序将一组数据分为多个分组，每个分组中的前后数据下标间隔为gap，将所有数据分到特定的分组。一组数据中假设gap为4（gap的分组数量不应大于数组总容量sz），则可以将这个数组中的数据分为4组，分组的规则为从数组首元素开始，相邻数据依次为不同的分组，如下标[0], [1], [2], [3]这四个数据分别为分组1,2,3,4，后续数据按照该规则循环进入各个分组即可。
1. 分组后的数据只应该在本组中进行数据的直接插入排序，即分组1成员间的数据不能与分组2或分组3的数据互相有数据交互，一个分组中的相邻数据之间的距离为gap，如分组1的第一个元素处于下标[0]，分组1的第二个元素处于下标[4]的位置。
1. 因为cur是数组中从前向后整体遍历的指针，所以要实现每个分组之间的插入排序，就只能不同组交替进行部分数据的插入排序，即分组1的[0]与[4]号元素插入排序后，cur指针后挪，开始进行分组2的[1]与[5]号元素排序。待4个分组进行了第一轮部分数据的插排完成后，如果此时cur指针没有越界，则开始进行第二轮从分组1开始的插排。

![希尔排序1](C:\Users\Shiki\Desktop\资料\博客\链表OJ题\图片素材\希尔排序1.gif)

4. 如上图所示，gap选择为4时将所有分组数据进行插排结束后，每个分组中的数据都相对保持有序了，此时每个分组有序但整体不有序的阶段叫作数组的阶段==预排序==，此后gap不断缩小，每缩小一次，分组数量就会减少，相应地每个分组数据成员就会增多，且当该次分组的插排结束后，每个分组间的数据都保持相对有序，整体上整个数组的数据从前向后就会越来越有序了。
5. 随着gap的减小与分组数量的随之减少，一个数组中的数据越来越接近有序，当gap为1时，此时数组中仅有一个分组，将该分组中的所有数据相互间保持有序，就是将整个数组的数据排成顺序，也就是完全的直接插入排序了。因为在gap为1之前进行过的几轮预排序中多少使数据间部分相互有序了，所以结合之前的经验，直接插入排序对一个接近有序或有序的数组调整效率是非常高的，所以最后一轮进行直接插入排序保证整个数组一定有序的时候，排序的难度就没有刚开始完全的乱序数组那么高了，所以速度和效率是很高的。

![希尔排序2](C:\Users\Shiki\Desktop\资料\博客\链表OJ题\图片素材\希尔排序2.gif)

6. 关于gap的取法，因为因为gap分组排序对于希尔算法来说很重要，当gap越大时，一次性跨越的数组中数据就越多，能更快将处于数组中后方的数据调整到前面，也就能更好地整体调整数据前后的相对位置，使同一个组中的数据保持前后相对有序，但是因为gap越大时一个组中的数据量越少，所以精度较差，整体有序水平不高。gap不断缩小，则每个组中数据越来越多，整趟调整下来后更多的数据就保持相对有序了。官方对gap的取值为初始为sz的一半，后续每次递减为前一次gap值的一半，如一个数组中数据量共有1000个，则首次gap为500，首轮调整完毕后下一次gap为250，再下一次为125，最后一次为1。但实际过程可以自己灵活调整gap，使数据间调整的次数更贴合实际。

🌈测试用例

```c
int arr[] = { 3,1,8,9,0,4,7,2,5,10,6 };		//排降序
int arr1[] = { 100,90,88,77,98,66,55,99,44,33,22,200,10,50,0 };		//排升序
int sz = sizeof(arr) / sizeof(int);
ShellSort(arr, sz);
for (int i = 0; i < sz; i++)
{
    printf("%d ", arr[i]);
}
```

🌈观察结果

```c
//降序结果
0 1 2 3 4 5 6 7 8 9 10
//升序结果
200 100 99 98 90 88 77 66 55 50 44 33 22 10 0
```

👑总结

希尔排序是一个不稳定的排序算法，因为虽然其运用到的直接插入排序可以保持整个数据的每组数据间相同数据的相对有序，但在经历多次分组和前后轮次不同组间的数据位置调整后，则可能造成相同数据的前后位置改变。

希尔排序前后共经历两个阶段，预排序和直接插入排序，预排序将不同数据分组，使每组数据前后相对有序。以升序为例，如果gap越大，越大的数将越快到达数组的后半部分，而更小的数则可以更快到达前面，但是整个数组越不接近有序。当gap随着每轮预排序循环每次减半或为前一次的1/3减少到1时，进入直接插入排序将接近有序的数组调整为有序数组，则此时整个数组中数据就有序了。

关于希尔排序的时间复杂度仍是一个难以计算的值，官方给定其介于O(N* logN)与O(N^2^)之间，即平均时间复杂度为O(N^1.3^)。



---

### 🌠选择排序

选择排序是对数据进行有意义的筛选，一般是取出全部数据的最大或最小值放在整个数组中的特定位置，以达成排序，取大或取小或TopK问题等特殊场景的使用。选择排序有两种比较经典的算法，一个是与冒泡，插排等时间复杂度相当的直接选择排序，其最大特点是方便理解，易于上手，但是是不稳定的算法。另一个是效率很高但也不稳定的堆排序算法，对于堆和堆排序已经在前面的章节重点介绍和论述，本章仅以代码展示与测试一笔带过。

#### 🍧直接选择排序

直接选择排序非常好理解，于冒泡排序算法一样需要对一个数组中的所有数据进行多次遍历，有一个外循环的整体遍历，以及一个内循环的多次搜索最大最小值的单趟遍历，内循环中遍历的主要任务是在一趟遍历中寻找最大值和最小值，找到后将这两个值分别与数组中现有的首尾值交换，向后遍历的过程中重复这一步骤，在一次次遍历后就可以保持最大，次大，最小，次小的值分别出现在数组的首尾两侧并不断向中间缩进，最终达到整个数组数据间的有序。

🎀直接选择排序

```c
void SelectSort(int* arr, int sz)
{
	for (int i = 0; i <= (sz - 1) / 2; i++)			//每次遍历取大取小两头排序，所以整体遍历只需遍历数组容量的一半
	{
		int max = i, min = i;						//定义单次遍历循环存储最大与最小值的临时变量
		for (int j = i + 1; j < sz - i; j++)		//排除掉首尾已经排好序的数据，每次单趟遍历仅对中间数据筛选
		{
			if (arr[min] > arr[j])					//取最小值下标
			{
				min = j;
			}
			if (arr[max] < arr[j])					//取最大值下标
			{
				max = j;
			}
		}
		Swap(&arr[max], &arr[sz - 1 - i]);			//升序算法
		if (min == sz - 1 - i)						//如果min值下标与末下标重合，使用max下标修正min下标
		{
			min = max;
		}
		Swap(&arr[min], &arr[i]);					//修正后再与首位置值进行数据互换
		//Swap(&arr[max], &arr[i]);					//降序算法
		//if (min == i)
		//{
		//	min = max;
		//}
		//Swap(&arr[min], &arr[sz - 1 - i]);
	}
}
```

1. 在选择排序算法中有很多细节是值得注意的，首先，与冒泡排序算法不断将最值数据冒到最右侧，后续排序对已经冒泡排序好的数据不再遍历相同，选择排序对一趟排序已经选择出的最大与最小数据与首尾交换后也不再对该对数据进行遍历了。简而言之，选择排序是一个不断向中间缩进排序的算法，对每趟选好的最大和最小数据放入到合适的位置后，就不再重复访问这些数据了，而是向其余的数据再次筛选，重复上一步骤。

![选择排序1](C:\Users\Shiki\Desktop\资料\博客\链表OJ题\图片素材\选择排序1.gif)

2. 由上图可知，整趟排序只需走总数组容量的一半即可，如果该数组容量为奇数，则当标识整趟遍历的首位置i超过中间下标时，整趟遍历结束，数组已经有序。如果该数组容量为偶数，则i超过中间两个元素的第一个元素下标时，遍历结束，数组有序。
3. 如果遇到最值元素与首尾位置下标值重合，这个时候需要特别注意，如果不修正位置将会造成最值重复交换，导致数据无意义交换的情况，如下图。

![选择排序2](C:\Users\Shiki\Desktop\资料\博客\链表OJ题\图片素材\选择排序2.gif)

4. 在升序的选择排序中，如果选出的最值数据与需要交换的数组范围中的首尾值有重合部分，比如最大值再首部，而最小值在尾部，此时按照正常思路让最大值与尾部交换，最小值再与首部交换，因为数值的交换是通过下标去控制的，所以第一次交换后，此时最小值下标对应的值已经由最大值存储了，如果此时不修正最小值min的指向，再将它认为指向的“最小值”与首部交换的话，会造成数据的复原，即最大值又回到了首部，而最小值也回到了尾部，这种交换是没有意义的。
5. 所以需要在第一次交换后，第二次交换前做出判断，以上例为例，如果第一次交换后尾部数据被最大值占据，则最小值下标min需要修正其指向，让其指向正确的最小值，而此时最小值正由最大值下标max所指向，所以让min = max，后续的最小值下标min与首部数据交换即可。

🌈测试用例

```c
int arr1[] = { -7,7,-10,6,6,2,10,8,1,0,3,-5,5};		//排升序
int arr2[] = { 10,8,6,4,2,1,0 };					//排降序
int arr3[] = { 4,5,1,6,3,9};						//排降序
int sz = sizeof(arr1) / sizeof(int);
SelectSort(arr1, sz);
for (int i = 0; i < sz; i++)
{
    printf("%d ", arr1[i]);
}
```

🌈观察结果

```c
//升序结果
-10 -7 -5 0 1 2 3 5 6 6 7 8 10
//降序结果
10 8 6 4 2 1 0
9 6 5 4 3 1
```

总结：

已经有序的情况下，选择最慢

时间复杂度O(N^2^)

在数组接近有序的情况下，没有插入排序好，因为仍然需要选出最大和最小，全部遍历完数组。而插入排序在接近有序的情况下，时度为O(N)。即使在乱序的情况下，因为局部可能有序的影响，插入排序仍然比选择排序的效率要高，因为选择排序需要完全遍历数组，以等差数列的时间遍历完并选出最大最小数，而插入排序只需要挪动前面有序部分的比新数据大或小的数，而不需要挪动再往前的数。

两者仅有在逆序数组的情况下效率一致，都是N^2^。最坏最好都是N^2^，即使冒泡优化下都好

对比插入排序，如果排序有序数组，都是O(N)；如果排序接近有序数组，则冒泡是O(2N)，插入是O(N)，所以总而言之插入更好一些。



---

#### 🍧堆排序

关于堆的排序和建堆方式已经在前面章节中详细阐述，本章仅作为与各个排序算法间的效率对比而供代码展示和测试。链接在此：

🎀建堆函数

```c
void HPCreate(int* arr, int sz, COM rule)
{
	int end = (sz - 2) / 2;						//从最后一个非叶子结点向前依次向下调整，直至调整到头结点
	while (end >= 0)
	{
		AdjustDownward(arr, sz, end, rule);		//向下调整建堆
		end--;
	}
}
```

其中用到了向下调整算法与标识建堆规则的函数指针

🎀建堆规则

```c
typedef bool(*COM)(int, int);		//比较大小的函数指针，返回真假
bool Ascend(int a, int b)			//用于取更大值给父节点的建大堆函数
{
	return a > b;
}
bool Descend(int a, int b)			//用于取更小值给父节点的建小堆函数
{
	return a < b;
}
```

🎀向下调整算法

```c
void AdjustDownward(int* arr, int sz, int parent, COM rule)
{
	int child = parent * 2 + 1;			//根据传入的父节点和公式计算左子结点下标
	while (child < sz)
	{
		if (child + 1 < sz && rule(arr[child + 1], arr[child]))		//对比右子结点值是否比左子值更大或更小
		{
			child = child + 1;										//如果条件成立，将待交换下标赋值于右子下标
		}
		if (rule(arr[child], arr[parent]))			//父子值对比，建大堆子比父大交换，建小堆子比父小交换
		{
			Swap(&arr[child], &arr[parent]);
			parent = child;							//子给父，继续向下迭代交换
			child = child * 2 + 1;					//子将自身当做父结点，通过公式向下找到左子结点
		}											//当子下标大于数组容量时停止迭代
		else
			break;
	}
}
```

建好堆以后，进行堆排序，升序建大堆，降序建小堆，堆排序规则与建堆规则保持一致

```c
void HPSort(int* arr, int sz, COM rule)
{
	int end = sz - 1;						//建堆完成后，定义堆末下标end
	while (end > 0)							//当end向前递减至堆顶下标，排序完成
	{
		Swap(&arr[0], &arr[end]);			//首尾交换，将最值数据沉淀到堆尾
		AdjustDownward(arr, end, 0, rule);	//堆顶数据向下调整保持堆结构，方便后续重复交换与调整
		end--;
	}
}
```

🌈测试用例

```c
int arr[] = { 6,1,8,10,5,4,7,6,5,10,6,0,0 };	//排升序，建大堆
int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };			//排降序，建小堆
int sz = sizeof(arr1) / sizeof(int);
HPCreate(arr, sz, Ascend);		//将Ascend改为Descend建小堆并排降序
HPSort(arr, sz, Ascend);
for (int i = 0; i < sz; i++)
{
    printf("%d ", arr[i]);
}
```

🌈观察结果

```c
//升序结果
0 0 1 4 5 5 6 6 6 7 8 10 10
//降序结果
10 9 8 7 6 5 4 3 2 1
```



### 🌠交换排序

#### 🍧冒泡排序

冒泡排序是最简单的一种交换排序，也是一种稳定的排序，它能够在不改变相同数据间相对顺序位置的情况下，将最值数据通过相邻数据的对比交换一个个排到数组后方，经过多轮排序后最终使整个数组值保持有序。

1. 经典的冒泡排序算法描述从一串数据的首元素下标开始，不断向后遍历。以升序为例，如果相邻的两个元素的前一个存在更大值，则将该值与后一个值交换，如果该值仍比其后一个元素大，再进行交换，这样通过层层交换可以把最大值在一遍从头到尾遍历中送到数组的最末端，即将最大值“冒”到了最后；次大数据在下一轮单趟冒泡中也会被“冒”到右侧第二个位置上，这样层层循环，当总循环进行了sz - 1次时，所有数据冒泡完毕，数组有序。
2. 总循环次数为sz - 1可以理解为共有多少对数据进行了比较，比如10个数据共有9对相互比较，4个数据共需要相互两两对比3次，所以总趟数是由数组中多少对数据决定的。而单趟排序为sz - 1 - i可以理解为每次单趟排序的总对数都比上一轮少一个，因为随着冒泡不断进行，总有最大或最小的数据被冒到了最后方或次后方，这些数据因为已经是最值数据沉淀到了后方，所以已经部分有序而没有必要再与它们进行两两比较了，所以单趟排序总会把上几轮已经冒过的数据排除开来，而仅对前几轮没处理过的前面部分的数据再对比。

![冒泡排序](C:\Users\Shiki\Desktop\资料\博客\链表OJ题\图片素材\冒泡排序.gif)

3. 在优化版的冒泡排序中我们加入了循环终止遍历标识flag，该变量的目的是如果数组在排序过程中已经有序，则无需再向后进行多余的遍历的多对数据的对比了，所以在一趟遍历结束后，如果这个标识flag没有被置假，则表示数组有序，直接break即可。

🎀优化版冒泡排序

```c
void BubbleSort(int* arr, int sz)
{
	for (int i = 0; i < sz - 1; i++)				//整趟排序循环，总次数为数组容量-1
	{
		bool flag = true;							//循环终止遍历标识，如果单趟循环下来flag保持为真，则已经有序
		for (int j = 0; j < sz - 1 - i; j++)		//单趟冒泡循环，根据已排好的数据量不断减少次数
		{
			if (arr[j] < arr[j + 1])				//规则可变，">"升序，"<"降序
			{
				Swap(&arr[j], &arr[j + 1]);			//相邻数据交换
				flag = false;						//如果存在数据交换，则当前数组不有序，将flag置反
			}
		}
		if (flag)		//如果单趟有序，则进入该判断，停止后续多余的无意义遍历再对比循环
		{
			break;
		}
	}
}
```

🌈测试用例

```c
int arr1[] = { -6,7,-15,6,3,2,1,8,1, 0 };		//排降序
int arr2[] = { 10,9,8,5,7,6,4,2,1,0, 3 };		//排升序
int sz = sizeof(arr1) / sizeof(int);
BubbleSort(arr1, sz);
for (int i = 0; i < sz; i++)
{
    printf("%d ", arr1[i]);
}
```

🌈观察结果

```c
//降序结果
8 7 6 3 2 1 1 0 -6 -15
//升序结果
0 1 2 3 4 5 6 7 8 9 10
```

👑总结

冒泡排序的时间复杂度为O(N^2^)，在有序或接近有序的情况下与插入排序一样是O(N)，且经过标识变量flag优化后效率有所提升，但在乱序或完全逆序的情况下效率仍然低的可怕。虽然它在交换排序算法中与其他神仙算法格格不入，但胜在该算法比较稳定，相同数据间的相对位置不会改，且比较好理解，对初学者而言是一个容易上手，概念相对易懂的好算法了。



---

#### 🍧快速排序



挖坑法

1. 选最左边数为key，右边出发找比key小，找到后将该数填到坑位上，该位置成为新坑位，左边出发找比key大

2. 单趟与hoare方法一样，可以将key排到正确位置上并使坑左边都比key小，右边都比key大

   ![image-20220714174642146](C:\Users\Shiki\AppData\Roaming\Typora\typora-user-images\image-20220714174642146.png)



快排优化

key的选择

如果只选最左边数做key，如果遇到有序数组，则时度为O(N^2^)

解决方法：

1. 随机数选key
2. 三数取中——首，中，末三个数中，去掉最大和最小，选不大不小的那个数

递归优化

直接插入排序混用

减少递归调用次数



![image-20220715202103628](C:\Users\Shiki\AppData\Roaming\Typora\typora-user-images\image-20220715202103628.png)